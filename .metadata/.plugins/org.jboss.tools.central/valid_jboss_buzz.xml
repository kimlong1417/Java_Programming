<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" media="screen" href="/~d/styles/atom10full.xsl"?><?xml-stylesheet type="text/css" media="screen" href="http://feeds.feedburner.com/~d/styles/itemcontent.css"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/"><title>JBoss Tools Aggregated Feed</title><link rel="alternate" href="http://tools.jboss.org" /><subtitle>JBoss Tools Aggregated Feed</subtitle><dc:creator>JBoss Tools</dc:creator><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/atom+xml" href="http://feeds.feedburner.com/jbossbuzz" /><feedburner:info xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" uri="jbossbuzz" /><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/" /><entry><title>How to build automated JFR rules with Cryostat 2.1's new UI</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/05/11/how-build-automated-jfr-rules-cryostat-21s-new-ui" /><author><name>Andrew Azores</name></author><id>ab6ad892-9bbe-4106-b3f4-70a4e385785e</id><updated>2022-05-11T07:00:00Z</updated><published>2022-05-11T07:00:00Z</published><summary type="html">&lt;p&gt;&lt;a href="https://cryostat.io"&gt;Cryostat&lt;/a&gt; is a tool for managing JDK Flight Recorder data on &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt;. Cryostat 2.1, the most recent version of the software, has a brand-new user interface for the automated rules that were previously introduced as an API feature in Cryostat 2.0. It is now much easier to manage &lt;a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm"&gt;JDK Flight Recording&lt;/a&gt; (JFR) on a large scale for many &lt;a href="https://developers.redhat.com/topics/enterprise-java"&gt;Java&lt;/a&gt; applications.&lt;/p&gt; &lt;h2&gt;The power of automated rules&lt;/h2&gt; &lt;p&gt;Automated rules trigger JFRs against target JVMs, offering powerful and flexible match expressions to determine which applications each rule applies to. These match expressions can refer to various properties of the target applications, such as the pod name (which can be compared using direct string equality or regular expressions), JMX port number, and any &lt;a href="https://developers.redhat.com/products/openshift/getting-started"&gt;OpenShift&lt;/a&gt; or Kubernetes labels and annotations present on the pod.&lt;/p&gt; &lt;p&gt;When a rule is created, Cryostat selects all the applications matched by the expression and starts a new recording using the JFR event template defined by the rule. The same thing happens whenever a new target application instance is discovered: Cryostat tests whether the new application instance matches an expression in a rule that has been previously created and, if so, starts a new recording using the event template.&lt;/p&gt; &lt;p&gt;Additionally, an automated rule can include options for copying the recordings out of the target application memory and into Cryostat's archives. The rule can specify how often the recording data should be copied and how many previous copies of this archived data to preserve, pruning the oldest.&lt;/p&gt; &lt;h2&gt;The new user interface&lt;/h2&gt; &lt;p&gt;A new user interface (UI) makes it easier than ever to get started with this powerful feature. Not only does the form view simplify interaction with the API by providing typed inputs (number pickers for durations, for instance), but it also includes a match expression wizard to help users craft the perfect expression to match the exact set of target applications they intend to observe (Figure 1).&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt; &lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/image2_2.png" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_full_width_1440px_w/public/image2_2.png?itok=YmSPHl5o" width="1440" height="820" alt="The UI for automated rules provides fields and other elements to control every aspect of the rule." loading="lazy" typeof="Image" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 1. The UI for automated rules provides fields and other elements to control every aspect of the rule. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 1: The UI for automated rules provides fields and other elements to control every aspect of the rule.&lt;/figcaption&gt; &lt;/figure&gt; &lt;p&gt;When you select a target, the match expression wizard provides a simple example of a match expression that could be used to match this target. This is meant simply as a hint to remind you of the match expression syntax.&lt;/p&gt; &lt;p&gt;The right side split portion of the view displays the selected target as a JSON structure. This shows you all of the information about the target application that you can refer to within the match expression (Figure 2).&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt; &lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/image1_6.png" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_full_width_1440px_w/public/image1_6.png?itok=5A2rjZ9V" width="1440" height="820" alt="On the right side of the page, all the parameters of an automated rule appear as JSON." loading="lazy" typeof="Image" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 2. On the right side of the page, all the parameters of an automated rule appear as JSON. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 2: On the right side of the page, all the parameters of an automated rule appear as JSON.&lt;/figcaption&gt; &lt;/figure&gt; &lt;p&gt;Once you have an idea of an expression that should match the applications you want, enter it into the match expression field. The UI will be updated to show a color-coded response to indicate whether your expression matches the currently selected target:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;Green&lt;/strong&gt; indicates that the expression matches the selected application.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Yellow&lt;/strong&gt; indicates that the expression given is a valid expression, but does not match the selected application.&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt; indicates that the given expression is invalid, most likely due to bad syntax.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If needed, adjust your match expression so that the indicator turns green and the expression matches the target. Next, select another target application that you want to apply the same automated rule to, and verify that the indicator is still green. If not, adjust the match expression again until it is green for both applications. You can also select an application that you do not want to match and verify that the indicator is yellow.&lt;/p&gt; &lt;p&gt;In Figure 3, I have written &lt;code&gt;target.labels.deployment == "quarkus-test"&lt;/code&gt; the match expression. The green color and checkmark indicate that this expression matches the selected target application.&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt; &lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/image3_3.png" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_full_width_1440px_w/public/image3_3.png?itok=PhldAgBY" width="1440" height="820" alt="A checkmark and green highlighting show a rule that matches a target application." loading="lazy" typeof="Image" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 3. A checkmark and green highlighting show a rule that matches a target application. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 3: A checkmark and green highlighting show a rule that matches a target application.&lt;/figcaption&gt; &lt;/figure&gt; &lt;p&gt;For more details and information about the match expression syntax, the automated rules API, and some example use cases, please refer to my previous article on Red Hat Developer, &lt;a href="https://developers.redhat.com/articles/2021/11/09/automating-jdk-flight-recorder-containers"&gt;Automating JDK Flight Recorder in containers&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;After you submit this form, you will return to the &lt;strong&gt;Automated Rules&lt;/strong&gt; view and should see the definition of your new rule appear in the table. Cryostat will immediately check all known target applications, evaluate whether the match expression applies to them, and, if so, start a recording using the defined settings. When future target applications are discovered, they will also be automatically checked against the match expression, with a recording started if necessary.&lt;/p&gt; &lt;h2&gt;Up next: How to label a Cryostat recording&lt;/h2&gt; &lt;p&gt;Cryostat 2.1 has a new feature for adding labels to recordings. When a recording is started by an automated rule, it automatically gains a label specifying the name of the rule responsible for starting the recording. This label also follows the recording into the archives if it is copied there. Watch this space for an article coming soon focusing on this feature.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/05/11/how-build-automated-jfr-rules-cryostat-21s-new-ui" title="How to build automated JFR rules with Cryostat 2.1's new UI"&gt;How to build automated JFR rules with Cryostat 2.1's new UI&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Andrew Azores</dc:creator><dc:date>2022-05-11T07:00:00Z</dc:date></entry><entry><title>Introducing Red Hat OpenShift extension for Docker Desktop</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/05/10/introducing-red-hat-openshift-extension-docker-desktop" /><author><name>Stevan Le Meur</name></author><id>a57251d9-5020-48f2-b0f4-69282d90303a</id><updated>2022-05-10T15:10:00Z</updated><published>2022-05-10T15:10:00Z</published><summary type="html">&lt;p&gt;Today we are announcing our new &lt;a href="https://developers.redhat.com/products/openshift/overview"&gt;Red Hat OpenShift&lt;/a&gt; extension for Docker Desktop, which helps developers with all of the different steps required to get an application running on &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt;. The extension aims to provide a bridge from your local environment to the environments where you run your applications.&lt;/p&gt; &lt;ul&gt; &lt;li aria-level="1"&gt;Get started easily with deploying and testing your application on Kubernetes.&lt;/li&gt; &lt;li aria-level="1"&gt;Ensure your applications are secure and follow best practices.&lt;/li&gt; &lt;li aria-level="1"&gt;Build your application with the target runtime environment in mind, knowing all the various prerequisites will be handled.&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;The Red Hat OpenShift extension for Docker Desktop&lt;/h2&gt; &lt;p&gt;The Red Hat OpenShift extension for Docker Desktop lets developers working with OpenShift deploy and test their applications with ease.&lt;/p&gt; &lt;p&gt;Simply choose your target environment and the project you want to deploy to and select the application image from the ones available on Docker Desktop. Then, the extension takes care of deploying the application on OpenShift. Typically, you'll use this extension once you have already built your application and containerized it.&lt;/p&gt; &lt;p&gt;Let’s see a &lt;a href="https://youtu.be/NhamWN1PisY"&gt;quick demo&lt;/a&gt;.&lt;/p&gt; &lt;h2&gt;Installation&lt;/h2&gt; &lt;p&gt;Starting with version 4.8, Docker Desktop provides new Extensions capabilities. You can find the Extensions Marketplace under the new section introduced in the sidebar.&lt;/p&gt; &lt;p&gt;Click "Add Extensions" to browse all available extensions for Docker Desktop. Locate the Red Hat OpenShift extension in the list. You can then install it with a single click.&lt;/p&gt; &lt;p class="Indent1"&gt;&lt;strong&gt;Note:&lt;/strong&gt; The extension works only with Red Hat OpenShift.&lt;/p&gt; &lt;h2&gt;Simplified Kubernetes development&lt;/h2&gt; &lt;p&gt;At Red Hat, we want to simplify the developer experience when using Kubernetes as the runtime environment for their applications.&lt;/p&gt; &lt;p&gt;Testing applications on Kubernetes—and testing in an environment as close as possible to the one used in production—can be a challenge. Getting an environment set up can also be difficult, and once that environment is available, we are exposed to new concepts and new paradigms. On top of that, there is also additional overhead to worry about with the extra config files we need to manage.&lt;/p&gt; &lt;p&gt;Even if we have the commonality of &lt;a href="https://developers.redhat.com/topics/containers"&gt;containers&lt;/a&gt;, getting them to run on Kubernetes can be a challenge. It’s not as easy as a “build and refresh,” and the turnarounds are getting slower.&lt;/p&gt; &lt;p&gt;This is why we build &lt;a href="https://developers.redhat.com/topics/developer-tools"&gt;developer tools&lt;/a&gt; to reduce friction and simplify the experience of testing and working with Kubernetes. This is what the new Red Hat OpenShift extension for Docker Desktop is all about!&lt;/p&gt; &lt;h2&gt;Key features&lt;/h2&gt; &lt;p&gt;The Red Hat OpenShift extension for Docker Desktop (Figure 1) provides the capabilities to:&lt;/p&gt; &lt;ul&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;Detect Kubernetes environments: &lt;/strong&gt; Scan defined kubeconfigs on your local environment and preselect your current default Kubernetes environment. You can also easily switch from one environment to another.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;Log in into clusters: &lt;/strong&gt;Directly connect to a new Kubernetes environment not yet configured on your local workstation.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;List projects (namespace): &lt;/strong&gt;Browse and select the project in which you want to deploy your application.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;Select container images:&lt;/strong&gt; Pick and choose any container image you already have built and deployed on a container registry.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;Deploy container images: &lt;/strong&gt; A container image gets deployed by building the necessary resources with the automatic creation of the route to expose the application outside of the cluster. Once deployed, the application opens in a new browser tab.&lt;/li&gt; &lt;/ul&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content"&gt; &lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/openshift-docker-desktop-extension.png" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_floated/public/openshift-docker-desktop-extension.png?itok=9JsYL66x" width="600" height="484" alt="OpenShift Extension for Docker Desktop" loading="lazy" typeof="Image" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 1: The Red Hat OpenShift extension for Docker Desktop user interface.&lt;/figcaption&gt; &lt;/figure&gt; &lt;h2&gt;Future roadmap&lt;/h2&gt; &lt;p&gt;In the future, we plan to add more capabilities, including:&lt;/p&gt; &lt;ul&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;Easy access to Kubernetes and OpenShift with the Developer Sandbox:&lt;/strong&gt; Leverage the &lt;a href="https://developers.redhat.com/developer-sandbox"&gt;Developer Sandbox for Red Hat OpenShift&lt;/a&gt; to access OpenShift environments in the cloud at no cost, with zero setup needed.&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;strong&gt;Watch mode:&lt;/strong&gt; Watch for changes in source code to automatically build, push, and deploy the application on the development cluster.&lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;Learn more and get involved&lt;/h2&gt; &lt;p&gt;If you’d like to learn more about the OpenShift extension for Docker Desktop, visit the following links:&lt;/p&gt; &lt;ul&gt; &lt;li aria-level="1"&gt;&lt;a href="https://github.com/redhat-developer/openshift-dd-ext"&gt;OpenShift Docker Desktop extension repository&lt;/a&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;a href="https://www.docker.com/blog/docker-extensions-discover-build-integrate-new-tools-into-docker-desktop"&gt;Docker Extensions: Discover, Build and Integrate New Tools into Docker Desktop&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;To share your feedback, suggestions, ideas, or report an issue, use &lt;a href="https://github.com/redhat-developer/openshift-dd-ext"&gt;the GitHub repository&lt;/a&gt; to start a discussion or file a bug.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/05/10/introducing-red-hat-openshift-extension-docker-desktop" title="Introducing Red Hat OpenShift extension for Docker Desktop"&gt;Introducing Red Hat OpenShift extension for Docker Desktop&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Stevan Le Meur</dc:creator><dc:date>2022-05-10T15:10:00Z</dc:date></entry><entry><title type="html">London OpenShift User Group - Talking Architecture Shop</title><link rel="alternate" href="http://www.schabell.org/2022/05/london-openshift-user-group-talking-architecture-shop.html" /><author><name>Eric D. Schabell</name></author><id>http://www.schabell.org/2022/05/london-openshift-user-group-talking-architecture-shop.html</id><updated>2022-05-10T15:00:00Z</updated><content type="html">My second trip this year takes me to London for some fun later this week at Devoxx UK 2022 and a chance to speak with our customers at the London OpenShift User Group. As the , Tuesday 10th May we have a special meeting of the London OpenShift User Group featuring: * Enterprise Portfolio Architecture - the open source way * Uncover the genius within your ranks - A live stream of the Keynote presentation from Red Hat Summit in Boston featuring Paul Cormier (President and CEO), Stefanie Chiras (Senior VP) and Matt Hicks (Executive VP) Below you'll find the slides from my talk. The event kicks off with a welcome and then I'll present the following, with slides included here for your viewing pleasure: TALKING ARCHITECTURE SHOP - EXPLORING OPEN SOURCE SUCCESS AT SCALE You've heard of large scale open source architectures, but have you ever wanted to take a serious look at these real life enterprise implementations that scale? This session takes attendees on a tour of multiple use cases covering enterprise challenges like integration, optimisation, cloud adoption, hybrid cloud management, healthcare, retail, manufacturing, financial services, and much more. Not only are these architectures interesting, but they are successful real life implementations featuring open source technologies and power many of your own online experiences. The attendee departs this session with a working knowledge of how to map general open source technologies to their solutions. Material covered is available freely online and attendees can use these solutions as starting points for aligning to their own solution architectures. Thanks for the time and lending me your ears!</content><dc:creator>Eric D. Schabell</dc:creator></entry><entry><title>Access RHEL with a Developer for Teams subscription</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/05/10/access-rhel-developer-teams-subscription" /><author><name>Brian Gollaher, Alex Krikos</name></author><id>ae941d00-4055-4a65-988a-badfc02e3c7f</id><updated>2022-05-10T13:41:02Z</updated><published>2022-05-10T13:41:02Z</published><summary type="html">&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Organizations that use CentOS Linux for their developers and run a Red Hat offering in their enterprise now have a Red Hat Enterprise Linux (RHEL) offering that can replace CentOS Linux with a RHEL subscription and all the benefits of the Red Hat Developer Program. The zero-cost Developer subscription for Teams provides customers access to RHEL for all their development work. This includes access to enough physical or virtual entitlements for all development needs and includes all the benefits of Red Hat Enterprise Linux, including rapid security updates, access to all the RHEL certifications, RHEL management tools, including Red Hat Satellite and Red Hat Insights,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;and access to RHEL extended lifecycle offerings. Developer support is available for customers through paid add-ons to the Developer for Teams subscription.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Customers can use Developer for Teams for:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Developing applications for RHEL and all its add-ons to run on all Red Hat products&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Providing in-house development teams with all the RHEL they need for building and testing their applications &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Application development, test, and continuous integration&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Multi-user development, build, test, and integration scenarios&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Organizations that want to choose a combination of paid and self-support options&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Additional benefits of the subscription include:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;ul&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Access to Red Hat Developer Program content&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Access to the Red Hat Customer Portal and Red Hat Knowledgebase&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li aria-level="1"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Getting started guides, documentation, and a rich catalog of certified applications&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Interested in learning more? &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux/centos-migration?options=production-environments"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;Click here&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; or &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a href="https://www.redhat.com/en/contact"&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;u&gt;&lt;span&gt;&lt;span&gt;talk to a Red Hatter&lt;/span&gt;&lt;/span&gt;&lt;/u&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; to learn more about the Developer subscription for Teams. &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/05/10/access-rhel-developer-teams-subscription" title="Access RHEL with a Developer for Teams subscription"&gt;Access RHEL with a Developer for Teams subscription&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Brian Gollaher, Alex Krikos</dc:creator><dc:date>2022-05-10T13:41:02Z</dc:date></entry><entry><title type="html">Simple external resources Testing with Quarkus</title><link rel="alternate" href="http://www.mastertheboss.com/soa-cloud/quarkus/simple-external-resources-testing-with-quarkus/" /><author><name>F.Marchioni</name></author><id>http://www.mastertheboss.com/soa-cloud/quarkus/simple-external-resources-testing-with-quarkus/</id><updated>2022-05-10T08:30:25Z</updated><content type="html">This is the second tutorial about Quarkus Testing. In this article we will learn how to test Quarkus applications that require Integration tests with external resources such as Databases, Messaging Brokers, Identity Servers and more. Overview of Quarkus Testing Firstly, we recommend checking this tutorial to have an overview of Quarkus Testing: How to Test ... The post appeared first on .</content><dc:creator>F.Marchioni</dc:creator></entry><entry><title>How to log into Cryostat 2.1 on OpenShift: SSO for all</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/05/10/sso-all-cryostats-new-openshift-login-flow" /><author><name>Janelle Law</name></author><id>32ce0d53-d39a-4038-8cf5-5756bb5b2744</id><updated>2022-05-10T07:00:00Z</updated><published>2022-05-10T07:00:00Z</published><summary type="html">&lt;p&gt;&lt;a href="https://cryostat.io"&gt;Cryostat&lt;/a&gt;, a tool for managing &lt;a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/about.htm#JFRUH170"&gt;JDK Flight Recorder&lt;/a&gt; data on &lt;a href="https://developers.redhat.com/topics/kubernetes"&gt;Kubernetes&lt;/a&gt;, is now integrated with the built-in OAuth server on &lt;a href="https://developers.redhat.com/openshift"&gt;Red Hat OpenShift&lt;/a&gt; as part of the tech preview release of Cryostat 2.1. When logging into Cryostat on OpenShift, you will be redirected to the OpenShift login page and prompted to enter the username and password corresponding to your OpenShift user account. Upon success, you can stay logged in during multiple sessions—for 24 hours by default.&lt;/p&gt; &lt;h2&gt;What does Cryostat use OpenShift authentication for?&lt;/h2&gt; &lt;p&gt;In order for Cryostat to monitor &lt;a href="https://developers.redhat.com/topics/enterprise-java"&gt;Java&lt;/a&gt; applications running in your &lt;a href="https://developers.redhat.com/topics/containers"&gt;containerized&lt;/a&gt; Java Virtual Machines (JVMs), Cryostat searches for target applications within the same namespace where Cryostat is deployed. This means that Cryostat needs permission from your OpenShift user account to discover Kubernetes objects such as pods and deployments. Whenever a user makes a request to start, stop, or save a JDK flight recording on a target application, Cryostat ensures that the user's requests come from the same namespace, and that the user has access to view and manage JDK flight recordings on each target application.&lt;/p&gt; &lt;h2&gt;Changes to Cryostat authentication since Cryostat 2.0&lt;/h2&gt; &lt;p&gt;Cryostat 2.0 required users to paste their authorization token from the OpenShift console into the Cryostat login page and re-enter their token upon refreshing a browser session. Cryostat 2.1 combines the OpenShift OAuth server with Cryostat's RBAC permissions to give users configurable permissions for each of their OpenShift user accounts. By default, each web browser session lasts 24 hours.&lt;/p&gt; &lt;h2&gt;How to log in to Cryostat 2.1&lt;/h2&gt; &lt;p&gt;This article assumes you have an instance of Cryostat running in an OpenShift 4.6+ cluster. You can check out the Cryostat &lt;a href="https://cryostat.io/get-started/"&gt;Get Started&lt;/a&gt; guide to learn how to install Cryostat.&lt;/p&gt; &lt;p&gt;Once you have an instance of Cryostat running, log in to the OpenShift web console, navigate to &lt;strong&gt;Installed Operators&lt;/strong&gt;, and select &lt;strong&gt;Cryostat Operator&lt;/strong&gt;. From there, select your desired Cryostat instance under the &lt;strong&gt;Cryostat&lt;/strong&gt; tab. Click the &lt;strong&gt;Application URL&lt;/strong&gt; link to access the login screen, where you can enter your username and password for your OpenShift user account.&lt;/p&gt; &lt;p&gt;For access to all of Cryostat's features, you may need to request RBAC permissions for your OpenShift user account. Users with limited permissions have access only to the Cryostat features for which they are authorized. For example, users with read-only permissions can view JDK flight recordings created by other users but cannot create or delete recordings. At the time of writing, the following user permissions are required to access all of the features in Cryostat:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-markdown"&gt;- apiGroups: - "" resources: - pods verbs: - create - get - apiGroups: - "" resources: - replicationcontrollers - endpoints verbs: - get - apiGroups: - operator.cryostat.io resources: - cryostats verbs: - create - delete - get - apiGroups: - operator.cryostat.io resources: - flightrecorders - recordings verbs: - create - delete - get - patch - apiGroups: - apps resources: - deployments verbs: - create - get - apiGroups: - apps resources: - daemonsets - replicasets - statefulsets verbs: - get &lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Overview of Cryostat RBAC permissions&lt;/h2&gt; &lt;p&gt;If more than one user is managing JDK flight recordings with Cryostat in a single namespace, and you want to give each user specific permissions for Cryostat features, create a role with your desired Cryostat-specific RBAC permissions and bind that role to the desired user account. In general, Cryostat uses &lt;code&gt;get&lt;/code&gt; permissions for the &lt;code&gt;apiGroups: ""&lt;/code&gt; and &lt;code&gt;apiGroups: apps&lt;/code&gt; resources listed in the previous section, to discover any target applications within the namespace. The &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, and &lt;code&gt;patch&lt;/code&gt; permissions for Cryostat's &lt;code&gt;flightrecorders&lt;/code&gt; and &lt;code&gt;recordings&lt;/code&gt; resources allow users to create, delete, retrieve, and save JDK flight recordings from their target applications.&lt;/p&gt; &lt;h2&gt;Conclusion&lt;/h2&gt; &lt;p&gt;This article explains how to log in to Cryostat 2.1 on OpenShift and outlines the required RBAC permissions for your user account. To learn more about defining RBAC permissions, visit the OpenShift Container Platform &lt;a href="https://docs.openshift.com/container-platform/4.10/authentication/using-rbac.html"&gt;documentation&lt;/a&gt;. For more information about Cryostat, visit &lt;a href="https://cryostat.io/get-started/"&gt;cryostat.io&lt;/a&gt;. For questions, comments, and feedback, feel free to connect with us on &lt;a href="https://github.com/cryostatio"&gt;Github&lt;/a&gt; or join our &lt;a href="https://groups.google.com/g/cryostat-development"&gt;mailing list&lt;/a&gt;.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/05/10/sso-all-cryostats-new-openshift-login-flow" title="How to log into Cryostat 2.1 on OpenShift: SSO for all"&gt;How to log into Cryostat 2.1 on OpenShift: SSO for all&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Janelle Law</dc:creator><dc:date>2022-05-10T07:00:00Z</dc:date></entry><entry><title>Using Unsafe safely in GraalVM Native Image</title><link rel="alternate" href="https://developers.redhat.com/articles/2022/05/09/using-unsafe-safely-graalvm-native-image" /><author><name>Ashutosh Mehra</name></author><id>731ce957-2d70-423e-b4d6-882d14975116</id><updated>2022-05-09T07:00:00Z</updated><published>2022-05-09T07:00:00Z</published><summary type="html">&lt;p&gt;The perils of using the &lt;code&gt;Unsafe&lt;/code&gt; class in &lt;a href="https://developers.redhat.com/topics/enterprise-java"&gt;Java&lt;/a&gt; applications are &lt;a href="https://blogs.oracle.com/javamagazine/post/the-unsafe-class-unsafe-at-any-speed"&gt;well documented&lt;/a&gt;. Although &lt;code&gt;Unsafe&lt;/code&gt; has historically offered access to low-level programming features, it exposes internal details of the implementation and its use is therefore highly discouraged. If you submit code that uses the &lt;code&gt;Unsafe&lt;/code&gt; API to the &lt;a href="https://www.graalvm.org/22.0/reference-manual/native-image/"&gt;GraalVM Native Image&lt;/a&gt; compiler, you can encounter even more problems that don't exist on dynamic JVMs such as HotSpot.&lt;/p&gt; &lt;p&gt;This article looks at the issues that GraalVM Native Image can potentially introduce with &lt;code&gt;Unsafe&lt;/code&gt;, and offers coding techniques that can help you achieve some of the goals you might want to use &lt;code&gt;Unsafe&lt;/code&gt; for. Among other things, we'll look at the &lt;code&gt;VarHandles&lt;/code&gt; API, which was introduced in the JDK as an alternative to some of the &lt;code&gt;Unsafe&lt;/code&gt; APIs.&lt;/p&gt; &lt;h2&gt;What is GraalVM Native Image?&lt;/h2&gt; &lt;p&gt;To begin with, let's go through a quick overview of how GraalVM Native Image works.&lt;/p&gt; &lt;p&gt;Native Image is an ahead-of-time compilation technology that performs static analysis of the complete application to find reachable components, and then statically compiles the code to produce a native executable. The static analysis includes points-to analysis that, in addition to identifying unused methods, also identifies the unused fields in a class and allows such fields to be excluded from the class definition (also called &lt;em&gt;class metadata&lt;/em&gt;) stored in the image.&lt;/p&gt; &lt;p&gt;To illustrate how fields are removed from the metadata, you can use the &lt;a href="https://www.sourceware.org/gdb/"&gt;GDB debugger&lt;/a&gt; to inspect the internal state when the native image is running. Please refer to the GraalVM documentation on the &lt;a href="https://www.graalvm.org/22.0/reference-manual/native-image/DebugInfo/"&gt;Debug Info feature&lt;/a&gt; for details on debugging a native image.&lt;/p&gt; &lt;p&gt;Let's consider the following code, stored in a file named &lt;code&gt;FieldDCETest.java&lt;/code&gt;. Note that &lt;code&gt;field2&lt;/code&gt; is not used, even though it is defined and an unused method even refers to it:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt; 1 class MyClass { 2 private int field1; 3 private int field2; 4 private int field3; 5 6 MyClass(int val1, int val2) { 7 field1 = val1; 8 field3 = val2; 9 } 10 11 int getField1() { return field1; } 12 int getField2() { return field2; } 13 int getField3() { return field3; } 14 } 15 16 public class FieldDCETest { 17 public static void main(String args[]) { 18 MyClass obj = new MyClass(10, 20); 19 System.out.println("field1: " + obj.getField1()); 20 System.out.println("field3: " + obj.getField3()); 21 return; 22 } 23 } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If we ask GDB to print the definition of the &lt;code&gt;MyClass&lt;/code&gt; type after it passes through the Native Image builder, the output shows:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;(gdb) ptype MyClass type = class MyClass : public java.lang.Object { private: int field1; int field3; public: MyClass(int, int); }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;code&gt;field2&lt;/code&gt; is not present in the type definition, because points-to analysis in Native Image builder eliminated it as an unused field.&lt;/p&gt; &lt;p&gt;In addition to static compilation, Native Image builder adds &lt;em&gt;build-time&lt;/em&gt; initialization. As the name suggests, build-time initialization runs class initializers at build time to eliminate the need for that activity at run time. However, Native Image builder actually relies on the JVM it is running on to execute the static class initializers. Keep this detail in mind, as you'll see its implications later.&lt;/p&gt; &lt;p&gt;The builder also creates a heap snapshot containing the objects created as part of running the class initializers.&lt;/p&gt; &lt;p&gt;Once the Native Image builder has identified all the reachable code and executed the class initializers, it compiles the reachable methods and generates a native executable.&lt;/p&gt; &lt;h2&gt;Unsafe proves to be unsafe&lt;/h2&gt; &lt;p&gt;Now let's see how the use of &lt;code&gt;Unsafe&lt;/code&gt; can create really "unsafe" situations when used in a native image with build-time initialization. The following file, &lt;code&gt;UnsafeTest.java&lt;/code&gt;, performs a typical operation that uses the &lt;code&gt;Unsafe&lt;/code&gt; API to get the offset of &lt;code&gt;field3&lt;/code&gt; within the class:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt; 1 import sun.misc.Unsafe; 2 import java.lang.reflect.Field; 3 4 public class UnsafeTest { 5 public int field1; 6 public int field2; 7 public int field3; 8 9 static long field3Offset; 10 static Unsafe unsafe; 11 12 static { 13 try { 14 Field f = Unsafe.class.getDeclaredField("theUnsafe"); 15 f.setAccessible(true); 16 unsafe = (Unsafe) f.get(null); 17 field3Offset = unsafe.objectFieldOffset(UnsafeTest.class.getField("field3")); 18 } catch (Exception e) { 19 throw new RuntimeException(e); 20 } 21 } 22 public static void main(String args[]) throws Exception { 23 System.out.println("field3Offset (from class initializer): " + field3Offset); 24 System.out.println("field3 offset: " + unsafe.objectFieldOffset(UnsafeTest.class.getField("field3"))); 25 } 26 } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The class initializer block for &lt;code&gt;UnsafeTest&lt;/code&gt; caches the offset of &lt;code&gt;field3&lt;/code&gt; using the &lt;code&gt;Unsafe&lt;/code&gt; API at line 17. Line 24 in &lt;code&gt;main()&lt;/code&gt; uses &lt;code&gt;Unsafe&lt;/code&gt; again to get the offset of that field.&lt;/p&gt; &lt;p&gt;Let's build the native image for this example and run it:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ javac UnsafeTest.java $ native-image UnsafeTest&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;$ ./unsafetest field3Offset (from class initializer): 12 field3 offset: 12&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;By default, the native image &lt;a href="https://www.graalvm.org/22.0/reference-manual/native-image/BuildConfiguration/#runtime-vs-build-time-initialization"&gt;runs class initializers&lt;/a&gt; for application classes at runtime, which can be verified using the &lt;code&gt;-H:+PrintClassInitialization&lt;/code&gt; option when building the native image. This option prints a report indicating the type of class initialization and the reason behind it for each class. The following command generates a class initialization report for the previous example:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ native-image -H:+PrintClassInitialization UnsafeTest&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This generates a file with the name &lt;code&gt;reports/class_initialization_report_&lt;timestamp&gt;.csv.&lt;/code&gt; For the previous example, the following entry can be found in the report:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;UnsafeTest, RUN_TIME, classes are initialized at run time by default&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Since the class initializer for &lt;code&gt;UnsafeTest&lt;/code&gt; and &lt;code&gt;UnsafeTest::main&lt;/code&gt; both get executed at run-time, the offset of the field is the same when computed both at line 17 and at line 24.&lt;/p&gt; &lt;p&gt;Now let's ask the image builder to initialize the &lt;code&gt;UnsafeTest&lt;/code&gt; class at build time using &lt;code&gt;--initialize-at-build-time=UnsafeTest&lt;/code&gt; and run the test again:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ native-image --initialize-at-build-time=UnsafeTest UnsafeTest&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This time the output is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ ./unsafetest field3Offset (from class initializer): 20 field3 offset: 12&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Hmm, that's unexpected. Why did the build time initialization of &lt;code&gt;UnsafeTest&lt;/code&gt; result in a different offset of the same field in the class initializer? Let's dissect the image creation process.&lt;/p&gt; &lt;p&gt;At build time, the image builder performs points-to reachability analysis and executes class initializers in tandem multiple times. During this phase, the builder executes the class initializer of the &lt;code&gt;UnsafeTest&lt;/code&gt; class, which computes the offset of &lt;code&gt;field3&lt;/code&gt;. As mentioned previously, the class initializer is executed by the JVM running the image builder.&lt;/p&gt; &lt;p&gt;For the JVM, the shape of &lt;code&gt;UnsafeTest&lt;/code&gt; instances looks like Figure 1. The JVM allocates 12 bytes for the object headers and 4 bytes for each of the integer fields, including &lt;code&gt;field1&lt;/code&gt; and &lt;code&gt;field2&lt;/code&gt;. Therefore, the offset of &lt;code&gt;field3&lt;/code&gt; computed in the class initializer and stored in the static &lt;code&gt;UnsafeTest::field3Offset&lt;/code&gt; variable is 20.&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt; &lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/offsets1_1.png" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_full_width_1440px_w/public/offsets1_1.png?itok=ofgMPx3E" width="190" height="151" alt="The JVM includes the unused field2 when calculating the size of the Unsafe object." loading="lazy" typeof="Image" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 1. The JVM includes the unused field2 when calculating the size of the Unsafe object. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 1: The JVM includes the unused field2 when calculating the size of the Unsafe object.&lt;/figcaption&gt; &lt;/figure&gt; &lt;p&gt;However, after the Native Image builder has completed the points-to analysis and executed the class initializers, it determines that &lt;code&gt;field1&lt;/code&gt; and &lt;code&gt;field2&lt;/code&gt; of &lt;code&gt;UnsafeTest&lt;/code&gt; have never been read or written to and are essentially dead fields. We already saw this in the previous example of &lt;code&gt;FieldDCETest.java&lt;/code&gt;, where &lt;code&gt;field2&lt;/code&gt; was removed from the class definition. So the image builder eliminates &lt;code&gt;field1&lt;/code&gt; and &lt;code&gt;field2&lt;/code&gt;, thus changing the shape of the &lt;code&gt;UnsafeTest&lt;/code&gt; instances in the native image to the structure shown in Figure 2.&lt;/p&gt; &lt;figure class="rhd-u-has-filter-caption" role="group"&gt; &lt;div class="rhd-c-figure"&gt; &lt;article class="media media--type-image media--view-mode-article-content-full-width"&gt; &lt;div class="field field--name-image field--type-image field--label-hidden field__items"&gt; &lt;a href="https://developers.redhat.com/sites/default/files/offset2_0.png" data-featherlight="image"&gt;&lt;img src="https://developers.redhat.com/sites/default/files/styles/article_full_width_1440px_w/public/offset2_0.png?itok=jKLYsQBE" width="189" height="75" alt="The Native Image builder notices unused fields and removes them, leaving only field3." loading="lazy" typeof="Image" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="field field--name-field-caption field--type-string field--label-hidden field__items"&gt; &lt;div class="rhd-c-caption field__item"&gt; Figure 2. The Native Image builder notices unused fields and removes them, leaving only field3. &lt;/div&gt; &lt;/div&gt; &lt;/article&gt; &lt;/div&gt; &lt;figcaption class="rhd-c-caption"&gt;Figure 2: The Native Image builder notices unused fields and removes them, leaving only field3.&lt;/figcaption&gt; &lt;/figure&gt; &lt;p&gt;This is the final shape of the &lt;code&gt;UnsafeTest&lt;/code&gt; instances, which is used at run time to compute the offset of &lt;code&gt;field3&lt;/code&gt; within the class. Accordingly, &lt;code&gt;field3&lt;/code&gt;'s offset is computed as 12.&lt;/p&gt; &lt;p&gt;In short, the difference in the field offset computed at build time and run time is due to different views of the class held by the Native Image builder and the JVM.&lt;/p&gt; &lt;p&gt;This example shows how the use of &lt;code&gt;Unsafe&lt;/code&gt; in the context of a native image can compound problems for developers, in addition to the usual concerns of being an unsupported API. Build-time initialization and points-to analysis can create situations where &lt;code&gt;Unsafe&lt;/code&gt; provides inconsistent results, thus becoming a source of subtle bugs in the application. These inconsistent results occur only in the native executable, so tests on the dynamic JVM wouldn't expose them.&lt;/p&gt; &lt;h2&gt;How to fix unsafe offset computations&lt;/h2&gt; &lt;p&gt;The GraalVM Native Image documentation mentions the problem with field offsets illustrated in the previous section and describes a couple of ways to &lt;a href="https://www.graalvm.org/22.0/reference-manual/native-image/Limitations/#unsafe-memory-access"&gt;work around it&lt;/a&gt;. We'll explore workarounds briefly before looking at a more reliable solution.&lt;/p&gt; &lt;h3&gt;An automatic fix&lt;/h3&gt; &lt;p&gt;One of the mechanisms employed by GraalVM Native Image is automatic detection of the code patterns that access &lt;code&gt;Unsafe.objectFieldOffset()&lt;/code&gt;. This mechanism tracks the fields that store the field offsets and rewrites them according to the final class shape. Logic for this process is in the &lt;a href="https://github.com/oracle/graal/blob/55ecc1d267cfad7750a104b3051a845332e4b59d/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/substitute/UnsafeAutomaticSubstitutionProcessor.java#L116"&gt;&lt;code&gt;UnsafeAutomaticSubstitutionProcessor&lt;/code&gt;&lt;/a&gt; class. However, the automatic detection has a couple of constraints:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;The argument passed to &lt;code&gt;Unsafe.objectFieldOffset()&lt;/code&gt; should be a constant, so that static analysis is able to identify the field for which the offset is being computed.&lt;/li&gt; &lt;li&gt;The field in which the offset is being stored should be declared static final.&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Our previous examples don't conform to the second constraint, and therefore would generate a warning message such as:&lt;/p&gt; &lt;pre&gt; &lt;code&gt;Warning: RecomputeFieldValue.FieldOffset automatic substitution failed. The automatic substitution registration was attempted because a call to sun.misc.Unsafe.objectFieldOffset(Field) was detected in the static initializer of UnsafeTest. Detailed failure reason(s): The field UnsafeTest.field3Offset, where the value produced by the field offset computation is stored, is not final. &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;To allow the image builder to automatically detect and handle the field offset for the previous example, all we need to do is declare &lt;code&gt;field3Offset&lt;/code&gt; as static final. With this change, the offset in &lt;code&gt;field3Offset&lt;/code&gt; is the same as the offset computed at run time in the &lt;code&gt;main()&lt;/code&gt; method:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ ./unsafetest field3Offset (from class initializer): 12 field3 offset: 12&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Substitution and annotations&lt;/h3&gt; &lt;p&gt;In real-world use cases, you might not be able to change a field declaration as easily—maybe the code comes from a third-party library, for instance, or perhaps the field really isn't final. So automatic detection would fail, and the image builder would need some hand-holding to be able to correctly recompute the fields that store field offsets. This is done using the &lt;a href="https://github.com/oracle/graal/blob/55ecc1d267cfad7750a104b3051a845332e4b59d/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/annotate/RecomputeFieldValue.java#L38"&gt;RecomputeFieldValue&lt;/a&gt; annotation. It depends on another powerful feature of GraalVM Native Image: &lt;em&gt;substitution&lt;/em&gt;.&lt;/p&gt; &lt;p&gt;Substitution allows you to replace parts of the target code with code that you provide. The main use case for this feature is to handle JDK or third-party code that trips over some of the constraints imposed by the Native Image builder. Because the code cannot be modified (unless you are ready to maintain your own fork of the source code of the library or JDK), you can use substitutions to provide compatible code.&lt;/p&gt; &lt;p&gt;Let's see this in action with our example, assuming that &lt;code&gt;UnsafeTest.field3Offset&lt;/code&gt; cannot be declared final. To mark this field with the &lt;code&gt;RecomputeFieldValue&lt;/code&gt; annotation, you need to add a substitution class for &lt;code&gt;UnsafeTest&lt;/code&gt;. We call this class &lt;code&gt;Target_UnsafeTest&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;@TargetClass(UnsafeTest.class) public final class Target_UnsafeTest { // user code here }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;&lt;code&gt;Target_UnsafeTest&lt;/code&gt; is annotated with &lt;code&gt;TargetClass&lt;/code&gt; specifying the name of the original class it is replacing, which in this case in &lt;code&gt;UnsafeTest&lt;/code&gt;. The purpose of this substitution class is to mark the field &lt;code&gt;UnsafeTest::field3Offset&lt;/code&gt; with the &lt;code&gt;RecomputeFieldValue&lt;/code&gt; annotation. So we add a field with the same name and type and annotate it as &lt;code&gt;Alias&lt;/code&gt;. In addition, we annotate the field with &lt;code&gt;RecomputeFieldValue &lt;/code&gt;and specify the kind of recomputation as &lt;code&gt;TranslateFieldOffset&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;@Alias @RecomputeFieldValue(kind = Kind.TranslateFieldOffset) static long field3Offset;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;These annotations tell the Native Image builder that the field &lt;code&gt;field3Offset&lt;/code&gt; in class &lt;code&gt;UnsafeTest&lt;/code&gt; holds a field offset and needs to be recomputed according to the final class shape, using the same field as before.&lt;/p&gt; &lt;p&gt;The complete code for &lt;code&gt;Target_UnsafeTest&lt;/code&gt; is:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt; 1 import com.oracle.svm.core.annotate.RecomputeFieldValue; 2 import com.oracle.svm.core.annotate.RecomputeFieldValue.Kind; 3 import com.oracle.svm.core.annotate.TargetClass; 4 import com.oracle.svm.core.annotate.Alias; 5 6 @TargetClass(UnsafeTest.class) 7 public final class Target_UnsafeTest { 8 /* UnsafeTest::field3Offset stores the field offset. Annotate it for recomputation. 9 * Recomputation is of type TranslateFieldOffset. 10 */ 11 @Alias @RecomputeFieldValue(kind = Kind.TranslateFieldOffset) 12 static long field3Offset; 13 } &lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;RecomputeFieldValue&lt;/code&gt; annotation supports many other kinds of&lt;em&gt; &lt;/em&gt;recomputation for different scenarios. For example, instead of &lt;code&gt;TranslateFieldOffset&lt;/code&gt;, we can use &lt;code&gt;FieldOffset&lt;/code&gt; by explicitly specifying the class and name of the field for which the offset is to be stored, as in:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt;@Alias @RecomputeFieldValue(kind = Kind.FieldOffset, declClassName="UnsafeTest", name="field3") static long field3Offset;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;If your application is using third-party libraries that use &lt;code&gt;Unsafe&lt;/code&gt; APIs that can cause the issues discussed in this article, substitution is the only way to make such code compatible with Native Image builder.&lt;/p&gt; &lt;p&gt;However, if you are able to modify such code, then you should avoid using &lt;code&gt;Unsafe&lt;/code&gt; APIs as much as possible. How to do that is the topic for the next section.&lt;/p&gt; &lt;h2&gt;VarHandles&lt;/h2&gt; &lt;p&gt;Variable handles were added in Java 9 to provide safe and supported alternatives to some of the &lt;code&gt;Unsafe&lt;/code&gt; APIs, with the aim of helping Java developers move away from &lt;code&gt;Unsafe&lt;/code&gt; APIs. &lt;code&gt;VarHandles&lt;/code&gt; modifiers provide read and write access to instance fields, static fields, and array elements under various access modes. A comprehensive explanation of &lt;code&gt;VarHandles&lt;/code&gt; can be found in &lt;a href="https://openjdk.java.net/jeps/193"&gt;JEP 193&lt;/a&gt;, the JDK Enhancement Proposal that introduced them.&lt;/p&gt; &lt;p&gt;What is relevant in the current context is that &lt;code&gt;VarHandles&lt;/code&gt; in GraalVM Native Image are implemented using the &lt;code&gt;Unsafe&lt;/code&gt; APIs to get the offset of the fields and to access the fields using these offsets.&lt;/p&gt; &lt;p&gt;Doesn't that mean &lt;code&gt;VarHandles&lt;/code&gt; would suffer from the same problems that we saw earlier when using &lt;code&gt;Unsafe&lt;/code&gt; to get field offsets at build time? They don't, because the JDK implementation for &lt;code&gt;VarHandles&lt;/code&gt; has a fixed set of classes that hold the field offsets in particular fields, and GraalVM Native Image has &lt;a href="https://github.com/oracle/graal/blob/01f337c74b48fbb67f4201dc02decfa79e949d74/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/VarHandleFeature.java#L263-L481"&gt;annotated such fields&lt;/a&gt; with the &lt;code&gt;RecomputeFieldValue&lt;/code&gt; annotation using the substitution mechanism that you saw in the previous section.&lt;/p&gt; &lt;p&gt;Let's write a program that accesses the field of an object. We will create two versions of this program: one using &lt;code&gt;Unsafe&lt;/code&gt; and one using &lt;code&gt;VarHandles&lt;/code&gt; to retrieve the value of a field. The first file is named &lt;code&gt;FieldAccessTestUnsafe.java&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt; 1 import sun.misc.Unsafe; 2 import java.lang.reflect.Field; 3 4 class FieldAccessor { 5 public static Object getFieldValue(Object obj, long offset) { 6 return UnsafeAccessor.unsafe.getInt(obj, offset); 7 } 8 } 9 10 class UnsafeAccessor { 11 public static Unsafe unsafe; 12 13 static { 14 try { 15 Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe"); 16 theUnsafe.setAccessible(true); 17 unsafe = (Unsafe) theUnsafe.get(null); 18 } catch (Exception e) { 19 throw new RuntimeException(e); 20 } 21 } 22 } 23 24 public class FieldAccessTestUnsafe { 25 public int field1; 26 public int field2; 27 public int field3; 28 29 static long field3Offset; 30 31 FieldAccessTestUnsafe() { 32 field3 = 100; 33 } 34 35 static { 36 try { 37 field3Offset = UnsafeAccessor.unsafe.objectFieldOffset(FieldAccessTestUnsafe.class.getField("field3")); 38 } catch (Exception e) { 39 throw new RuntimeException(e); 40 } 41 } 42 43 public static void main(String args[]) throws Exception { 44 FieldAccessTestUnsafe unsafeTest = new FieldAccessTestUnsafe(); 45 System.out.println("field3: " + unsafeTest.field3); 46 System.out.println("field value using precomputed offset: " + FieldAccessor.getFieldValue(unsafeTest, field3Offset)); 47 } 48 }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The &lt;code&gt;FieldAccessTestUnsafe&lt;/code&gt; class is similar to the &lt;code&gt;UnsafeTest&lt;/code&gt; class from the previous example. It uses &lt;code&gt;field3Offset&lt;/code&gt; to retrieve the value of &lt;code&gt;field3&lt;/code&gt;. The value of &lt;code&gt;field3Offset&lt;/code&gt; itself is retrieved using the &lt;code&gt;FieldAccessor&lt;/code&gt; helper class, which uses the &lt;code&gt;Unsafe&lt;/code&gt; API.&lt;/p&gt; &lt;p&gt;Compile this class and create a native image by initializing &lt;code&gt;FieldAccessTestUnsafe&lt;/code&gt; and &lt;code&gt;UnsafeAccessor&lt;/code&gt; at build time using the following commands:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ javac FieldAccessTestUnsafe.java $ native-image --initialize-at-build-time=FieldAccessTestUnsafe,UnsafeAccessor FieldAccessTestUnsafe fieldaccesstestunsafe&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Running the native image generates the following output:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ ./fieldaccesstestunsafe field3: 100 field value using precomputed offset: 0&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;The field value obtained using the offset computed during build time is clearly incorrect. As mentioned in the previous section, to get the correct value at run time, we would need to create a substitution class to recompute the field offset stored in &lt;code&gt;field3Offset&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Now we will rewrite the previous example using &lt;code&gt;VarHandle&lt;/code&gt; API. The file is named &lt;code&gt;FieldAccessTestVarHandle.java&lt;/code&gt;:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-java"&gt; 1 import java.lang.invoke.MethodHandles; 2 import java.lang.invoke.VarHandle; 3 4 class FieldAccessor { 5 public static Object getFieldValue(Object obj, VarHandle fieldHandle) { 6 return fieldHandle.get(obj); 7 } 8 } 9 10 public class FieldAccessTestVarHandle { 11 public int field1; 12 public int field2; 13 public int field3; 14 15 private static final VarHandle field3Handle; 16 17 FieldAccessTestVarHandle() { 18 field3 = 100; 19 } 20 21 static { 22 try { 23 field3Handle = MethodHandles.lookup().findVarHandle(FieldAccessTestVarHandle.class, "field3", int.class); 24 } catch (Exception e) { 25 throw new RuntimeException(e); 26 } 27 } 28 29 public static void main(String args[]) throws Exception { 30 FieldAccessTestVarHandle unsafeTest = new FieldAccessTestVarHandle(); 31 System.out.println("field3: " + unsafeTest.field3); 32 System.out.println("field value using varhandle: " + FieldAccessor.getFieldValue(unsafeTest, field3Handle)); 33 } 34 }&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Here, we have updated &lt;code&gt;FieldAccessor::getFieldValue() &lt;/code&gt;to use a &lt;code&gt;VarHandle&lt;/code&gt;. Notice that on line 23 in the &lt;code&gt;FieldAccessTestVarHandle&lt;/code&gt;'s class initializer block we are now creating a &lt;code&gt;VarHandle&lt;/code&gt; for &lt;code&gt;field3&lt;/code&gt;.&lt;/p&gt; &lt;p&gt;Compile this class and create a native image by initializing &lt;code&gt;FieldAccessTestVarHandle&lt;/code&gt; at build time using the following commands:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ javac FieldAccessTestVarHandles.java $ native-image --initialize-at-build-time=FieldAccessTestVarHandles FieldAccessTestVarHandles fieldaccesstestvarhandles&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Running the native image generates the following output:&lt;/p&gt; &lt;pre&gt; &lt;code class="language-bash"&gt;$ ./fieldaccesstestvarhandles field3: 100 field value using varhandle: 100&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;This time the value obtained using &lt;code&gt;VarHandles&lt;/code&gt; is correct.&lt;/p&gt; &lt;p&gt;This example demonstrates how &lt;code&gt;VarHandles&lt;/code&gt; can help developers avoid the need to use GraalVM's substitution mechanism to recompute field offsets. This approach is much cleaner and more easily maintained than adding substitution classes.&lt;/p&gt; &lt;h2&gt;Conclusion&lt;/h2&gt; &lt;p&gt;We looked at how the use of &lt;code&gt;Unsafe&lt;/code&gt; APIs can result in potential problems when using GraalVM Native Image builder. We also looked at how the image builder tries to address the issues by identifying common patterns of accessing field offsets using &lt;code&gt;Unsafe&lt;/code&gt;. However, if the application is using &lt;code&gt;Unsafe&lt;/code&gt; in complex patterns, manual intervention is required in the form of substitution classes and annotations. All these problems can be avoided if the application or library is rewritten to use &lt;code&gt;VarHandles&lt;/code&gt;.&lt;/p&gt; The post &lt;a href="https://developers.redhat.com/articles/2022/05/09/using-unsafe-safely-graalvm-native-image" title="Using Unsafe safely in GraalVM Native Image"&gt;Using Unsafe safely in GraalVM Native Image&lt;/a&gt; appeared first on &lt;a href="https://developers.redhat.com/blog" title="Red Hat Developer"&gt;Red Hat Developer&lt;/a&gt;. &lt;br /&gt;&lt;br /&gt;</summary><dc:creator>Ashutosh Mehra</dc:creator><dc:date>2022-05-09T07:00:00Z</dc:date></entry><entry><title type="html">Portfolio Architecture Examples - Application Development Collection</title><link rel="alternate" href="http://www.schabell.org/2022/05/portfolio-architecture-examples-application-development-collection.html" /><author><name>Eric D. Schabell</name></author><id>http://www.schabell.org/2022/05/portfolio-architecture-examples-application-development-collection.html</id><updated>2022-05-09T05:00:00Z</updated><content type="html">  Figure 1: The portfolio architecture process For a few years now we've been working on a project we have named . These are based on selecting a specific use case we are seeing used in the real world by customers and then finding implementations of that case using three or more products from the Red Hat portfolio. This basic premise is used as the foundation, but many aspects of open source are included in both the process and the final product we have defined. There is a community, where we share the initial project kickoff with a group of architects and use their initial feedback from the start. We also present the architecture product we've created right at the end before we publish to ensure usability by architects in the field. The final publish product includes some internal only content around the customer projects researched, but most of the content is  through various open source channels.  This article is sharing an overview of the product we've developed, what's available to you , and concludes by sharing a collection of architectures we've published. INTRODUCTION The basis of a portfolio architecture is a use case, two to three actual implementations that can be researched, and includes the use of a minimum of three products. This is the ideal foundation for a project to start, but we encountered a problem with use cases containing emerging technologies or emerging domains in the market. To account for these we've chosen to note the fact that these are opinionated architectures based on internal reference architectures.  The product has been defined as complete for publishing when it contains the following content: * Short use case definition * Diagrams - logical, schematic (physical), and detail diagrams * Public slide deck containing the use case story and architecture diagrams * Internal slide deck containing both the public deck content and the confidential customer research * Video (short) explanation of the architecture * Either a technical brief document or one or more articles covering the solution architecture Note that the items in italics are all available to anyone  in the Red Hat Portfolio Architecture Center or in the Portfolio Architecture Examples repository. FIGURE 2: LOGICAL DIAGRAM DESIGN TEMPLATE TOOLING AND WORKSHOPS The progress towards our products required a good idea of how we wanted to diagram our architectures. We chose to keep them very generic and simple in style to facilitate all levels of conversation around a particular use case without getting bogged down in notational discussions.  A simple three level design for our architectures was captured by using logical, schematic, and detail diagrams. All of these have been integrated in  with pre-defined templates and icons for easily getting started. Furthermore, we've developed a tooling workshop to quickly ramp up on the design methods and tooling we've made available. It's called , has been featured in several. APPLICATION DEVELOPMENT COLLECTION The collection featured today is centered around architectures supporting application development and cloud development. There are currently fifteen architectures in this collection and we'll provide a short overview of each, leaving the in depth exploration as an exercise for the reader. Figure 3: Application development architecture collection In each of these architecture overviews you'll find a table of contents outlining the technologies used, several example schematic diagrams with descriptions, and a link in the last section to open the diagrams directly into the online tooling in your browser. Retail is the process of selling consumer goods or services to customers through multiple channels of distribution to earn a profit. Retailers satisfy demand identified through a supply chain. The term retailer is typically applied where a service provider fills the small orders of many individuals, who are end-users, rather than large orders of a small number of wholesale, corporate or government clientele. The use case is optimising delivery routing, automating rostering of staff, and improving efficiency of tasks across multiple stores. Cloud native development is an approach to building and running applications to fully use the advantages of the cloud computing model (i.e., responsive, elastic, and resilient applications). Red Hat empowers organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers and orchestration, DevOps and continuous delivery, microservices and service meshes, and declarative application programming interfaces (APIs) are key building blocks of cloud-native application development. These technologies and techniques deliver loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow businesses to make high-impact application improvements frequently and predictably with minimal effort and risk. Additionally, cloud native architecture and technologies provide the foundation for newer development models such as serverless computing and Functions-as-a-Service. The use case is an approach to building and running applications to fully exploit the advantages of the cloud computing model (i.e. responsive, elastic and resilient applications). An omnichannel approach provides a unified customer experience across platforms, creating a single view for customers to interact with their own information. Red Hat provides a foundation for IT teams to develop and deliver omnichannel services through a combination of integration and process automation technologies. Agile integration defines how organizations are transforming and delivering on their digital promise to customers by integrating applications and services across on-premise infrastructure and cloud environments. Business automation, in the form of process integrations, are captured to enable access to complex process services. The use case for omnichannel implies integration and orchestration of channels such that the experience of engaging across all the channels someone chooses to use. This architecture covers edge medical diagnosis in the healthcare industry. It Accelerates medical diagnosis using condition detection in medical imagery with AI/ML at medical facilities. The use case is accelerating medical diagnosis using condition detection in medical imagery with AI/ML at medical facilities. Retail is the process of selling consumer goods or services to customers through multiple channels of distribution to earn a profit. The term electronic commerce (e-commerce) refers to a business model that allows companies and individuals to buy and sell goods and services over the Internet. The use case is deploying a container based e-commerce website while moving away from tightly coupled existing e-commerce platform. Integrating with Software-as-a-Service (SaaS) applications is the process of operationally connecting SaaS solutions to other separate computer systems or applications into a single larger system, allowing each solution to functionally work together. The use case is providing integration with SaaS applications, platforms, and services empowers organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Intelligent DaaS (Data as a Service) is about building and delivery of systems and platforms in a secure and scalable manner while driving data needs for moving towards consumerisation in healthcare. Feel free to explore this portfolio architecture by clicking on the diagram below. The use case is Intelligent Data as a Service (iDaaS) is about building and delivery of systems and platforms in a secure and scalable manner while driving data needs for moving towards consumerisation in healthcare. Data synthesis is about enabling innovation with a focus around enabling massive amounts of data to be available for business users and developers needs in a secure and scalable manner. The use case is modernising testing with data synthesis, a testing innovation with focus around enabling massive amounts of data to be available for both business users and developers in a secure and scalable manner. Financial services institutions understand that today’s banking customers expect fast, easy-to-use services they can tap into anytime, anywhere, and are therefore accelerating adoption of digital technologies to enable a variety of new offerings. (Note: this project is a new architecture and currently in progress, so sharing one of the schematic architecture diagrams and you can monitor this project for updates as it progresses to completion.) The use case is a cloud ready, modular open source approach offering a wide range of technology options and allows low-effort integration covering all aspects of an Open Banking implementation. An offering of (near) real-time payments lets businesses, consumers, and even governments send and accept funds that provide both availability to the recipient and instant confirmation to the sender. Enabling real-time - or at least faster - payments that improve the speed of online payment experiences to customers has the potential to give banks a greater opportunity to win, serve, and retain their customers. By building solutions that capture real-time payment business, banks also can drive higher payment volumes, ideally at lower costs as well as engage new customer segments. The use case examines financial institutions enabling customers with fast, easy to use, and safe payment services available anytime, anywhere. Retail is the process of selling consumer goods or services to customers through multiple channels of distribution to earn a profit. A point of sale, or point of purchase, is where you ring up customers. When customers check out online, walk up to your counter, or pick out an item from your stand or booth, they're at the point of sale. Your point-of-sale system is the hardware and software that enables your business to make those sales. The use case is simplifying and modernising central management of distributed point-of-sale devices with built in support for container based applications. Retail is the process of selling consumer goods or services to customers through multiple channels of distribution to earn a profit. Real-time inventory management is an automated process of recording sales and purchases through the use of software. It gives you a complete picture of what's happening with inventory, allowing your business to react quickly to supply chain needs. The use case is providing (near) real-time stock positions and dynamic pricing promotions information to retailer omnichannels. Retail is the process of selling consumer goods or services to customers through multiple channels of distribution to earn a profit. A data framework refers to the process of managing enterprise retail data. The framework or system sets the guidelines and rules of engagement for business and management activities, especially those that deal with or result in the creation and manipulation of data. The use case is creating a framework for access to retail data from customers, stock, stores, and staff across multiple internal teams. Retail is the process of selling consumer goods or services to customers through multiple channels of distribution to earn a profit. Store health and safety is all about managing risks to protect workers and stores. In a global context, health and safety is also an essential part of the movement towards sustainable operational growth. The use case is managing effective in-store compliance, health &amp;amp; safety, and employee checks and procedures. Retail is the process of selling consumer goods or services to customers through multiple channels of distribution to earn a profit. Supply chain integration is a large-scale business strategy that brings as many links of the chain as possible into a closer working relationship with each other. The goal is to improve response time, production time, and reduce costs and waste. The use case is streamlining integration between different elements of a retail supply chain for on-premise, cloud, and other third-party interactions. If you are interested in more architecture solutions like these, feel free to explore the . More architecture collections include: * * * * * * * * *</content><dc:creator>Eric D. Schabell</dc:creator></entry><entry><title type="html">WildFly Cloud Testsuite</title><link rel="alternate" href="https://wildfly.org//news/2022/05/08/YAML-wildflly-cloud-testsuite/" /><author><name>Kabir Khan</name></author><id>https://wildfly.org//news/2022/05/08/YAML-wildflly-cloud-testsuite/</id><updated>2022-05-08T23:00:00Z</updated><content type="html">In addition to the WildFly zip download familiar to a lot of our users, a big part of the WildFly story is that it is very usable on the cloud. And of course for that we have a lot of tests, many of which are currently private. We now have a proof of concept public cloud testsuite which can be found at . It does not aim to run the full testsuite from . Rather, we want to focus attention on areas relevant to the cloud. So far it includes tests for: * our container launch scripts actually being able to connect to a database when configured with the documented environment variables to do so * configmaps and secrets can be read by the MicroProfile subsystem * being able to connect to Kafka provided by the operator * that we are able to execute CLI command and REST calls on a server running on a pod It is still a proof of concept, but is something we’re actively working on, so expect to see this grow and evolve as we identify more things we want to test. Once things are more settled we will move it over to the main wildfly organisation in GitHub. On the Java side, we are currently using as our underlying framework, but are evaluating other alternatives. There are helpers to be able to connect to the correct pods running the application from the tests. More could be done to make the experience smoother. This will be done once we decide which framework to invest in. Also, it is quite flexible when it comes to the underlying framework, so we will be able to switch tests to something else in steps - it does not all need to be done in one go. Currently, the tests work against a locally running Kubernetes instance. This makes sense for the framework in its beginning since Openshift is based on Kubernetes, and of course very important for us to support. We will look at other cloud providers in the future, and also expand it to use Openshift as needed, i.e. when Kubernetes does not offer everything we need. The hope is that the testsuite can become a nice reference point for 'power users' to be able to see how to use WildFly on Openshift/Kubernetes, and provide ideas for how you can test your applications when running on OpenShift. Please see the project for more instructions on how to write tests. If you would like to get involved, file issues in the repository for things you would like to see implemented (as well as for bug reports). If you would like to discuss something more abstract, the repository also has discussions enabled. Enjoy :-)</content><dc:creator>Kabir Khan</dc:creator></entry><entry><title type="html">This Week in JBoss - May 7th 2022</title><link rel="alternate" href="https://www.jboss.org/posts/weekly-2022-05-07.html" /><category term="quarkus" /><category term="java" /><category term="kubernetes" /><category term="cryostat" /><category term="jvm" /><category term="jfr" /><category term="openshift" /><category term="knative" /><category term="serverless" /><author><name>Stefan Sitani</name><uri>https://www.jboss.org/people/stefan-sitani</uri><email>do-not-reply@jboss.com</email></author><id>https://www.jboss.org/posts/weekly-2022-05-07.html</id><updated>2022-05-07T00:00:00Z</updated><content type="html">&lt;article class="" data-tags="quarkus, java, kubernetes, cryostat, jvm, jfr, openshift, knative, serverless"&gt; &lt;h1&gt;This Week in JBoss - May 7th 2022&lt;/h1&gt; &lt;p class="preamble"&gt;&lt;/p&gt;&lt;p&gt;Welcome to the May 7th edition of the JBoss weekly editorial. The last few weeks have been rich in both new releases from your favorite projects, and also new and interesting content brought to you by your favorite authors and contributors. And with the Red Hat Summit happening this week, we all have even more goodies to look forward to. Today, we’re looking at highlights from all over the community. From Cryostat to Kafka to Knative and Quarkus, we have plenty to choose from, so sit back and enjoy this week’s selection.&lt;/p&gt;&lt;p&gt;&lt;/p&gt; &lt;div class="sect1"&gt; &lt;h2 id="_releases_releases_releases"&gt;Releases, releases, releases!&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;p&gt;Here are the releases from the JBoss Community for this edition:&lt;/p&gt; &lt;div class="ulist square"&gt; &lt;ul class="square"&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://camel.apache.org/blog/2022/05/RELEASE-3.14.3/"&gt;Camel 3.14.3 LTS&lt;/a&gt; and &lt;a href="https://camel.apache.org/blog/2022/05/RELEASE-3.11.7/"&gt;3.11.7 LTS&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://camel.apache.org/blog/2022/04/camel-k-release-1-9/"&gt;Camel K 1.9.0&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://debezium.io/blog/2021/12/16/debezium-1.8-final-released/"&gt;Debezium 1.9.2&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://in.relation.to/2022/05/06/hibernate-orm-601-final/"&gt;Hibernate ORM 6.0.1&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://resteasy.dev/2022/04/26/resteasy-6.1.0.Beta2/"&gt;RESTEasy 6.1.0.Beta2&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://quarkus.io/blog/quarkus-2-8-3-final-released/"&gt;Quarkus 2.8.3 - Maintenance release&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="sect1"&gt; &lt;h2 id="_articles_blogs"&gt;Articles &amp;#38; Blogs&lt;/h2&gt; &lt;div class="sectionbody"&gt; &lt;div class="sect2"&gt; &lt;h3 id="_monitoring_quarkus_jvm_mode_with_cryostat"&gt;Monitoring Quarkus JVM mode With Cryostat&lt;/h3&gt; &lt;p&gt;&lt;a href="https://quarkus.io/blog/monitoring-quarkus-jvm-mode-with-cryostat/"&gt;Monitoring Quarkus JVM Mode With Cryostat&lt;/a&gt; by Andrew Azores&lt;/p&gt; &lt;p&gt;&lt;a href="https://cryostat.io/"&gt;Cryostat&lt;/a&gt; is a container-native implementation of JDK Flight Recorder (JFR) for monitoring the JVM performance in workloads that run on an OpenShift cluster. Andrew Azores walks you through installing the Cryostat Operator and setting up a Cryostat instance to monitor a Quarkus application running in JVM mode. He also adds a few educational points about Cryostat’s JMX target discovery strategies and the limitations of using Cryostat to monitor Quarkus applications running in native mode.&lt;/p&gt; &lt;/div&gt; &lt;div class="sect2"&gt; &lt;h3 id="_use_red_hats_sso_to_manage_kafka_broker_authorization"&gt;Use Red Hat’s SSO to manage Kafka broker authorization&lt;/h3&gt; &lt;p&gt;&lt;a href="https://developers.redhat.com/articles/2022/05/04/use-red-hats-sso-manage-kafka-broker-authorization#"&gt;Use Red Hat’s SSO to manage Kafka broker authorization&lt;/a&gt; by Ken Lee and Niti Upadhyay&lt;/p&gt; &lt;p&gt;Ken Lee and Niti Upadhyay’s post is a detailed deep dive into combining the Kafka ACL management capabilities provided by Red Hat SSO and the user and group permission management model of OpenLDAP to control publishing and consumption access of LDAP users to specific Kafka topics. The article opens with an architecture overview of the example project, and follows with up with a detailed end-to-end walkthrough of how to to get the required service up and running on OpenShift. The walkthrough steps contain extensive code examples and section providing background information. The article is accompanied by a demo video presented by Ken Lee.&lt;/p&gt; &lt;/div&gt; &lt;div class="sect2"&gt; &lt;h3 id="_the_red_hat_cloud_way_event_driven_serverless_distributed_cloud_services_to_support_modern_apps"&gt;The Red Hat Cloud way: Event-driven, serverless, distributed cloud services to support modern apps&lt;/h3&gt; &lt;p&gt;&lt;a href="https://developers.redhat.com/articles/2022/05/03/red-hat-cloud-way-event-driven-serverless-distributed-cloud-services-support"&gt;The Red Hat Cloud way: Event-driven, serverless, distributed cloud services to support modern apps&lt;/a&gt; by Natale Vinto and Sebastien Blanc&lt;/p&gt; &lt;p&gt;This short tie-in article for a Red Hat Summit 2022 talk by Natale Vinto and Sebastien Blanc sets stage for the speakers' presentation on the future of cloud-native development with Red Hat’s Cloud Services and Application Services portfolios. Natale and Sebastien will take you on a journey of developing a microservice-based application with Red Hat OpenShift Streams for Apache Kafka and Developer Sandbox for OpenShift that supports serverless, event-driven, on-demand workloads and can adapt to a wide range of purposes. including IoT, edge computing, and big data analytics. If you missed this talk at this years Summit, be sure to catch the recording.&lt;/p&gt; &lt;/div&gt; &lt;div class="sect2"&gt; &lt;h3 id="_comparing_distributed_transaction_patterns_for_microservices"&gt;Comparing Distributed Transaction Patterns for Microservices&lt;/h3&gt; &lt;p&gt;&lt;a href="http://www.ofbizian.com/2022/05/comparing-distributed-transaction.html"&gt;Comparing Distributed Transaction Patterns for Microservices&lt;/a&gt; by Bilgin Ibryam&lt;/p&gt; &lt;p&gt;Drawing on his vast experience wit working on customer projects as a Solution Architect, Bilgin invites you along on a deep-dive into the technical challenges of using distributed transactions to write data to multiple systems of record in microservice-based applications. He lays out four proven design approaches to making your app write predictably into multiple data storage resources and evaluates the benefits and drawback of each one, in terms of complexity, robustness, and scalability. Bilgin includes multiple examples and references to these patters as they are used in real-world enterprise applications today.&lt;/p&gt; &lt;/div&gt; &lt;div class="sect2"&gt; &lt;h3 id="_videos"&gt;Videos&lt;/h3&gt; &lt;p&gt;This week there was plenty of fresh content to choose from, so pleas enjoy some of my top video picks:&lt;/p&gt; &lt;div class="ulist"&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://youtu.be/CfDI0XsdxA0"&gt;Quarkus Renarde: an old-school Web framework with today’s touch&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://youtu.be/vbLRO8xJWy8"&gt;Quarkus Insights #87: Keycloak Quarkus Distribution&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://youtu.be/MwJB93hhHak"&gt;Quarkus Insights #88: Quarkus Scheduler&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://youtu.be/2hmBVhquZzQ"&gt;Distributed Tracing Integration with OpenTelemetry, Knative, and Quarkus&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;&lt;a href="https://youtu.be/LJ7m7Q4nR3U"&gt;Event-driven Autoscaling on Kubernetes: Use case 1 - HPA with Kafka&lt;/a&gt;&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;p&gt;&lt;em&gt;That’s all for today! Please join us again in two weeks for another round of our JBoss editorial!&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="author"&gt; &lt;pfe-avatar pfe-shape="circle" pfe-pattern="squares" pfe-src="/img/people/stefan-sitani.png"&gt;&lt;/pfe-avatar&gt; &lt;span&gt;Stefan Sitani&lt;/span&gt; &lt;/div&gt;&lt;/article&gt;</content><dc:creator>Stefan Sitani</dc:creator></entry></feed>
